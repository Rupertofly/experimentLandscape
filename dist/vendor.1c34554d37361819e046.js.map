{"version":3,"sources":["webpack:///vendor.1c34554d37361819e046.js","webpack:///./~/b-spline/index.js"],"names":["webpackJsonp","module","exports","__webpack_require__","interpolate","t","degree","points","knots","weights","result","i","j","s","l","n","length","d","Error","domain","low","high","v","alpha"],"mappings":"AAAAA,cAAc,IAER,SAAUC,EAAQC,EAASC,GAEjC,YCFA,SAASC,GAAYC,EAAGC,EAAQC,EAAQC,EAAOC,EAASC,GAEtD,GAAIC,GAAEC,EAAEC,EAAEC,EACNC,EAAIR,EAAOS,OACXC,EAAIV,EAAO,GAAGS,MAElB,IAAGV,EAAS,EAAG,KAAM,IAAIY,OAAM,qCAC/B,IAAGZ,EAAUS,EAAE,EAAI,KAAM,IAAIG,OAAM,uDAEnC,KAAIT,EAGF,IADAA,KACIE,EAAE,EAAGA,EAAEI,EAAGJ,IACZF,EAAQE,GAAK,CAIjB,IAAIH,GAOF,GAAGA,EAAMQ,SAAWD,EAAET,EAAO,EAAG,KAAM,IAAIY,OAAM,8BAPvC,CAET,GAAIV,KACJ,KAAIG,EAAE,EAAGA,EAAEI,EAAET,EAAO,EAAGK,IACrBH,EAAMG,GAAKA,EAMf,GAAIQ,IACFb,EACAE,EAAMQ,OAAO,EAAIV,GAIfc,EAAOZ,EAAMW,EAAO,IACpBE,EAAOb,EAAMW,EAAO,GAGxB,KAFAd,EAAIA,GAAKgB,EAAOD,GAAOA,GAEhBA,GAAOf,EAAIgB,EAAM,KAAM,IAAIH,OAAM,gBAGxC,KAAIL,EAAEM,EAAO,GAAIN,EAAEM,EAAO,MACrBd,GAAKG,EAAMK,IAAMR,GAAKG,EAAMK,EAAE,IADLA,KAO9B,GAAIS,KACJ,KAAIX,EAAE,EAAGA,EAAEI,EAAGJ,IAAK,CAEjB,IADAW,EAAEX,MACEC,EAAE,EAAGA,EAAEK,EAAGL,IACZU,EAAEX,GAAGC,GAAKL,EAAOI,GAAGC,GAAKH,EAAQE,EAEnCW,GAAEX,GAAGM,GAAKR,EAAQE,GAIpB,GAAIY,EACJ,KAAIT,EAAE,EAAGA,GAAGR,EAAO,EAAGQ,IAEpB,IAAIH,EAAEE,EAAGF,EAAEE,EAAEP,EAAO,EAAEQ,EAAGH,IAIvB,IAHAY,GAASlB,EAAIG,EAAMG,KAAOH,EAAMG,EAAEL,EAAO,EAAEQ,GAAKN,EAAMG,IAGlDC,EAAE,EAAGA,EAAEK,EAAE,EAAGL,IACdU,EAAEX,GAAGC,IAAM,EAAIW,GAASD,EAAEX,EAAE,GAAGC,GAAKW,EAAQD,EAAEX,GAAGC,EAMvD,IAAIF,GAASA,KACb,KAAIC,EAAE,EAAGA,EAAEM,EAAGN,IACZD,EAAOC,GAAKW,EAAET,GAAGF,GAAKW,EAAET,GAAGI,EAG7B,OAAOP,GAITT,EAAOC,QAAUE","file":"vendor.1c34554d37361819e046.js","sourcesContent":["webpackJsonp([1],[\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction interpolate(t, degree, points, knots, weights, result) {\n\n  var i, j, s, l; // function-scoped iteration variables\n  var n = points.length; // points count\n  var d = points[0].length; // point dimensionality\n\n  if (degree < 1) throw new Error('degree must be at least 1 (linear)');\n  if (degree > n - 1) throw new Error('degree must be less than or equal to point count - 1');\n\n  if (!weights) {\n    // build weight vector of length [n]\n    weights = [];\n    for (i = 0; i < n; i++) {\n      weights[i] = 1;\n    }\n  }\n\n  if (!knots) {\n    // build knot vector of length [n + degree + 1]\n    var knots = [];\n    for (i = 0; i < n + degree + 1; i++) {\n      knots[i] = i;\n    }\n  } else {\n    if (knots.length !== n + degree + 1) throw new Error('bad knot vector length');\n  }\n\n  var domain = [degree, knots.length - 1 - degree];\n\n  // remap t to the domain where the spline is defined\n  var low = knots[domain[0]];\n  var high = knots[domain[1]];\n  t = t * (high - low) + low;\n\n  if (t < low || t > high) throw new Error('out of bounds');\n\n  // find s (the spline segment) for the [t] value provided\n  for (s = domain[0]; s < domain[1]; s++) {\n    if (t >= knots[s] && t <= knots[s + 1]) {\n      break;\n    }\n  }\n\n  // convert points to homogeneous coordinates\n  var v = [];\n  for (i = 0; i < n; i++) {\n    v[i] = [];\n    for (j = 0; j < d; j++) {\n      v[i][j] = points[i][j] * weights[i];\n    }\n    v[i][d] = weights[i];\n  }\n\n  // l (level) goes from 1 to the curve degree + 1\n  var alpha;\n  for (l = 1; l <= degree + 1; l++) {\n    // build level l of the pyramid\n    for (i = s; i > s - degree - 1 + l; i--) {\n      alpha = (t - knots[i]) / (knots[i + degree + 1 - l] - knots[i]);\n\n      // interpolate each component\n      for (j = 0; j < d + 1; j++) {\n        v[i][j] = (1 - alpha) * v[i - 1][j] + alpha * v[i][j];\n      }\n    }\n  }\n\n  // convert back to cartesian and return\n  var result = result || [];\n  for (i = 0; i < d; i++) {\n    result[i] = v[s][i] / v[s][d];\n  }\n\n  return result;\n}\n\nmodule.exports = interpolate;\n\n/***/ })\n]);\n\n\n// WEBPACK FOOTER //\n// vendor.1c34554d37361819e046.js","\n\nfunction interpolate(t, degree, points, knots, weights, result) {\n\n  var i,j,s,l;              // function-scoped iteration variables\n  var n = points.length;    // points count\n  var d = points[0].length; // point dimensionality\n\n  if(degree < 1) throw new Error('degree must be at least 1 (linear)');\n  if(degree > (n-1)) throw new Error('degree must be less than or equal to point count - 1');\n\n  if(!weights) {\n    // build weight vector of length [n]\n    weights = [];\n    for(i=0; i<n; i++) {\n      weights[i] = 1;\n    }\n  }\n\n  if(!knots) {\n    // build knot vector of length [n + degree + 1]\n    var knots = [];\n    for(i=0; i<n+degree+1; i++) {\n      knots[i] = i;\n    }\n  } else {\n    if(knots.length !== n+degree+1) throw new Error('bad knot vector length');\n  }\n\n  var domain = [\n    degree,\n    knots.length-1 - degree\n  ];\n\n  // remap t to the domain where the spline is defined\n  var low  = knots[domain[0]];\n  var high = knots[domain[1]];\n  t = t * (high - low) + low;\n\n  if(t < low || t > high) throw new Error('out of bounds');\n\n  // find s (the spline segment) for the [t] value provided\n  for(s=domain[0]; s<domain[1]; s++) {\n    if(t >= knots[s] && t <= knots[s+1]) {\n      break;\n    }\n  }\n\n  // convert points to homogeneous coordinates\n  var v = [];\n  for(i=0; i<n; i++) {\n    v[i] = [];\n    for(j=0; j<d; j++) {\n      v[i][j] = points[i][j] * weights[i];\n    }\n    v[i][d] = weights[i];\n  }\n\n  // l (level) goes from 1 to the curve degree + 1\n  var alpha;\n  for(l=1; l<=degree+1; l++) {\n    // build level l of the pyramid\n    for(i=s; i>s-degree-1+l; i--) {\n      alpha = (t - knots[i]) / (knots[i+degree+1-l] - knots[i]);\n\n      // interpolate each component\n      for(j=0; j<d+1; j++) {\n        v[i][j] = (1 - alpha) * v[i-1][j] + alpha * v[i][j];\n      }\n    }\n  }\n\n  // convert back to cartesian and return\n  var result = result || [];\n  for(i=0; i<d; i++) {\n    result[i] = v[s][i] / v[s][d];\n  }\n\n  return result;\n}\n\n\nmodule.exports = interpolate;\n\n\n\n// WEBPACK FOOTER //\n// ./~/b-spline/index.js"],"sourceRoot":""}